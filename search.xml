<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[行存储和（HBase）列存储的区别]]></title>
    <url>%2F2018%2F07%2F11%2FRow-based-storage%2F</url>
    <content type="text"><![CDATA[原理 Row-based storage stores atable in a sequence of rows Column-based storage storesa table in a sequence of columns 优缺点行式存储下一张表的数据都是放在一起的，但列式存储下都被分开保存了。所以它们就有了如下这些优缺点： 列存储为什么快 减少了磁盘IO 随机读变成了连续读]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Hbase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Huffman-Tree]]></title>
    <url>%2F2018%2F07%2F11%2FHuffman-Tree%2F</url>
    <content type="text"><![CDATA[概览给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。 特点哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。 构造方法假设有n个权值，则构造出的哈夫曼树有n个叶子结点，n个权值分别设为 w1、w2、…、wn 将w1、w2、…，wn看成是有n 棵树的森林(每棵树仅有一个结点) 在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和 从森林中删除选取的两棵树，并将新树加入森林 重复(2)、(3)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树 注意为了使得到的哈夫曼树的结构尽量唯一，通常规定生成的哈夫曼树中每个结点的左子树根结点的权小于等于右子树根结点的权 应用在数据通信中，让使用频率高的用短码，使用频率低的用长码，以优化整个报文编码]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Huffman Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hash indexes and B-Trees]]></title>
    <url>%2F2018%2F07%2F11%2FB-Trees%2F</url>
    <content type="text"><![CDATA[Hash IndexesBitcaskDeleting records If you want to delete a key and its associated value, you have to append a special deletion record to the data file (sometimes called a tombstone). When log segments are merged, the tombstone tells the merging process to discard any previous values for the deleted key. Crash recovery you can restore each segment’s hash map by reading the entire segment file from beginning to end and noting the offset of the most recent value for every key as you go along. However, that might take a long time if the segment files are large, which would make server restarts painful. Bitcask speeds up recovery by storing a snapshot of each segment’s hash map on disk, which can be loaded into memory more quickly. Concurrency control As writes are appended to the log in a strictly sequential order, a common implementation choice is to have only one writer thread. Data file segments are append-only and otherwise immutable, so they can be read concurrently by multiple threads. append-only design turns out to be good for several reasons: Appending and segment merging are sequential write operations, which are generally much faster than random writes Concurrency and crash recovery are much simpler if segment files are append- only or immutable. For example, you don’t have to worry about the case where a crash happened while a value was being overwritten, leaving you with a file con‐ taining part of the old and part of the new value spliced together. 合并操作能使有用的数据文件更加紧凑 limitations The hash table must fit in memory, so if you have a very large number of keys, you’re out of luck. In principle, you could maintain a hash map on disk, but unfortunately it is difficult to make an on-disk hash map perform well. It requires a lot of random access I/O Range queries are not efficient. SSTables and LSM-TreesSSTable(Sorted String Table) sequence of key-value pairs is sorted by key each key only appears once within each merged segment fileSSTable 优势 Merging segments用了归并排序，保证新合并的segment依然有序，注意当多个segment出现相同的key时，取most recent segment In order to find a particular key in the file, you no longer need to keep an index of all the keys in memory. 取而代之的是一个稀疏的索引You still need an in-memory index to tell you the offsets for some of the keys, but it can be sparse 支持range query disk writes are sequential the LSM-tree can support remarkably high write throughputConstructing and maintaining SSTables When a write comes in, add it to an in-memory balanced tree data structure (for example, a red-black tree). This in-memory tree is sometimes called a memtable. When the memtable gets bigger than some threshold, write it out to disk as an SSTable file In order to serve a read request, first try to find the key in the memtable, then in the most recent on-disk segment, then in the next-older segment, etc. From time to time, run a merging and compaction process in the background to combine segment files and to discard overwritten or deleted values This scheme works very well. It only suffers from one problem: if the database crashes, the most recent writes (which are in the memtable but not yet written out to disk) are lost. In order to avoid that problem, we can keep a separate log on disk to which every write is immediately appended, just like in the previous section. That log is not in sorted order, but that doesn’t matter, because its only purpose is to restore the memtable after a crash. Every time the memtable is written out to an SSTable, the corresponding log can be discarded. Performance optimizations 当查找一个不存在的key时，首先去memtable找，然后从近到远依次找segment，所以为了避免这种情况发生，storage engines often use additional Bloom filters B-TreesConstructing log-structured indexes 将数据拆分成一个个大小可变的segment，并且能够满足顺序写，与之相比的是B-Trees将数据拆分成大小固定的blocks or pages, traditionally 4 KB in size (sometimes bigger), 一次只能读或者写一个page 一个page就是树的一个节点，每个节点指向多个儿子，节点的儿子数量被称为branching factor 当加入一个key的时候，如果符合条件的page空间被占满，这时这个page会被拆分成2个page，然后再更新他们的parent指针Making B-trees reliable write-ahead log (WAL, also known as a redo log)This is an append-only file to which every B-tree modification must be written before it can be applied to the pages of the tree itself, When the data‐base comes back up after a crash, this log is used to restore the B-tree back to a consistent state concurrency control is required if multiple threads are going to access the B-tree at the same time, 此时需要用锁B-tree optimizations Instead of overwriting pages and maintaining a WAL for crash recovery, some databases (like LMDB) use a copy-on-write scheme. 改动过的page会存在另外一个地方，并且它的父亲page会指向这个新儿子 不用存整个key的名称，只存能标识它的‘缩写’，这样可以节约空间，增加一个page的branching factor，从而缩小depth 存在兄弟指针，保证顺序遍历key的时候不用回到父节点 当大范围查询的时候，直接顺序遍历叶子节点Comparing B-Trees and LSM-TreesAs a rule of thumb,LSM-trees are typically faster for writes,whereas B-trees are thought to be faster for reads one write to the database resulting in multiplewrites to the disk over the course of the database’s lifetime—is known as write amplification. LSM-trees 能维持更高的写吞吐量，一部分是因为更小的write amplification，另一部分是因为顺序写真实他妈快啊]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>B-tree</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Suffix Tree 后缀数组]]></title>
    <url>%2F2013%2F03%2F28%2Fsuffix-tree%2F</url>
    <content type="text"><![CDATA[前言这是13年3月28日的文章，那时的我在机房熬了一天一夜翻来覆去看罗穗骞的代码，最后才把这个后缀数组给整明白了，故有此文现在的我回想那过去的岁月，难免唏嘘不已，今时今日借整理此文，以缅怀那过去的岁月吧！原文链接 声明我的模板是根据 罗穗骞 和 网上一模板 相结合改编而来，层次更加分明，数组名称的选择是根据用途来定义的，总的来说应该更好理解一些先声明一些概念： k-后缀数组：我这里用的是 sa[ ] ( k ) k-名次数组：我这里用的是 rank[ ] ( k ) 思路知道rank[ ] (1) 先求出sa[ ] (1)，然后根据 sa[ ] (1) 和 rank[ ] (1) 调用sorting函数求出 sa[ ] (2)，再求出rank[ ] (2) 等等 总的过程是rank[ ] (1)—-&gt;sa[ ] (1) —&gt;rank[ ] (2) —&gt; sa[ ] (2) —&gt; rank[ ] (k) —-&gt;sa[ ] (k) Hint 我的数组小标全是从1开始的，程序运行前一定要初始化函数ini() 其它该有的东西都在代码里，建议一边看代码下面的图，一边理解！ 模板代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;#define N 3000//处理完成之后下标都是从1开始char s[N];//存原始数据int sum[N], rank[2*N], trank[2*N];//sum用来基数排序；trank === temp-rankint sa[N], tsa[N]; //这里tsa[]用来保存第二关键字排序后的结果int Top, n; //Top基数排序出现的极大值void ini() //初始化&#123; n=strlen(s); memset(sum,0,sizeof(sum)); memset(rank,0,sizeof(rank)); memset(sa,0,sizeof(sa)); Top=128;&#125;void sorting(int k)&#123; int p = 1; //利用sa排序第二关键字，求出tsa for(int i = n-k+1; i &lt;= n; i++) tsa[p++]=i; //超出范围的下标按下标顺序置其名次为最低 for(int i = 1; i &lt;= n; i++) if(sa[i]&gt;=k+1) tsa[p++]=sa[i]-k; //按sa排名从小到大遍历，如果排名为i的某后缀(sa[i])位置在k后面，那么这个后缀肯定会在第二关键字排序 //(tsa[])中出现并且排在比较靠前的位置，这个后缀对应tsa[]中的位置为sa[i]-k memset(sum,0,sizeof(sum)); for(int i = 1; i &lt;= n; i++)sum[rank[i]]++; for(int i = 1; i &lt;= Top; i++)sum[i]+=sum[i-1]; for(int i = n; i &gt; 0; i--)sa[sum[rank[tsa[i]]]--]=tsa[i];//这句话应该是关键 //如果把tsa[i]换成i，那么就是对rank[i]按第一关键字排序求sa[]，事实上这段程序也是这样， //不过把i换成tsa[i]后会多一个功能，就是按第一关键字排序rank相同的情况下，会按第二关键字排， //这也正符合我们最终要求的sa[](2k)。具体方法是从tsa[n]到tsa[1]，让在第二关键字排名靠后的优先 //取sum较大的，取一次，sum--，如果后边第二关键字排名靠前的某后缀在第一关键字下rank和它相同， //那么它的sum就较小，在sa中排名就会靠前，服从排序规律！&#125;void get_sa()&#123; int p; for(int i = 0; i &lt; n; i++) rank[i+1]=s[i]; //仔细想一下，其实此时rank就是rank[](1); for(int i = 1; i &lt;= n; i++) sum[rank[i]]++; for(int i = 1; i &lt;= Top; i++) sum[i]+=sum[i-1]; //sum[i] means the number of the &lt;= rank[i]; for(int i = n; i &gt; 0; i--) sa[sum[rank[i]]--]=i; //sa[](1)构造完成 for(int k = 1; k &lt;= n; k&lt;&lt;=1) &#123; sorting(k); //由sa[](k)和rank[](k) 求 sa[](2k) //求rank[](2k) trank[sa[1]]=1; p=1; for(int i = 2; i &lt;= n; i++) &#123; if((rank[sa[i]]!=rank[sa[i-1]])||(rank[sa[i]+k]!=rank[sa[i-1]+k]))p++; trank[sa[i]]=p; &#125; for(int i = 1; i &lt;= n; i++)rank[i]=trank[i]; if(p&gt;=n)break; //rank[1,2……n]已经唯一了，即后缀大小已经唯一确定了，不需要继续执行了 Top=p;//下次基数排序的最大值 &#125;&#125;int height[N];void get_height()&#123; for(int i = 1, j = 0; i &lt;= n; i++) &#123; if(rank[i]==1)continue; for(;s[i+j-1]==s[sa[rank[i]-1]+j-1];)j++;//i从1开始，所以在原串中要-1 height[rank[i]]=j; if(j&gt;0)j--; &#125;&#125; int *RMQ=height;int mm[N];int best[20][N];void initRMQ(int n)&#123; int i,j,a,b; for(mm[0]=-1,i=1; i&lt;=n; i++) mm[i]=((i&amp;(i-1))==0)?mm[i-1]+1:mm[i-1]; for(i=1; i&lt;=n; i++)best[0][i]=i; for(i=1; i&lt;=mm[n]; i++)for(j=1; j&lt;=n+1-(1&lt;&lt;i); j++) &#123; a=best[i-1][j]; b=best[i-1][j+(1&lt;&lt;(i-1))]; if(RMQ[a]&lt;RMQ[b])best[i][j]=a; else best[i][j]=b; &#125;&#125;int askRMQ(int a,int b)&#123; int t; t=mm[b-a+1]; b-=(1&lt;&lt;t)-1; a=best[t][a]; b=best[t][b]; return RMQ[a]&lt;RMQ[b]?a:b;&#125;//求sufix(a)与sufix(b)的最长公共前缀长度，用上面的RMQ优化int lcp(int a,int b) //这里的a,b是字符串当中的位置，注意要从1开始&#123; int t; a=rank[a],b=rank[b]; if(a&gt;b) &#123; t=a; a=b; b=t; &#125; return height[askRMQ(a+1,b)];&#125; h[i] &gt;= h[i-1]-1的证明设suffix(k)是排在suffix(i-1)前一位的后缀，则它们的最长公共前缀显然是h[i-1]。那么，suffix(k+1)显然将排在suffix(i)的前面。并且，suffix(k+1)&amp;suffix(i) 相对于 suffix(k)&amp;suffix(i-1)来说就是同时去掉了第一位，即少了一位的匹配数。所以suffix(i)和前一名次后缀的最长公共前缀至少是h[i-1]-1 为什么是 至少h[i-1]-1的理解根据上面的证明我们可以得到suffix(k+1)&amp;suffix(i) == h[i-1]-1又因为suffix(k+1)显然将排在suffix(i)的前面所以 LCP(k+1,i) = h[i-1]-1 =min{ LCP(j-1, j) |k+1 ≤j ≤i } （LCP Theorem）&lt;= h[i]@(数据结构)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Suffix Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博弈进行时]]></title>
    <url>%2F2012%2F12%2F04%2Fgame-theory%2F</url>
    <content type="text"><![CDATA[前言这是 2012年12月04日 00:13:42 发表的博客，那时的我初生牛犊不怕虎，天天都在做final梦，在数据结构、动态规划还没整明白的情况下贸然开始搞博弈，实乃too simple。博弈现在基本上是忘到爪哇岛去了，投入的精力不知道还剩几斤几两。不过想想当年，确实挺热血的嘛！ 小知识点HDOJ2176 取(m堆)石子游戏 [输出第一步走法] 若给出的是必胜状态：a1^a2^…….^an=k,(其中k不为零)，那么我们的目的是要把必胜状态转化为必败状态从 而使得先手胜利。 若a1^a2^…^an!=0，一定存在某个合法的移动，将ai改变成ai’后满足a1^a2^…^ai’^…^an=0。 若a1^a2^…^an=k，则一定存在某个ai，它的二进制 表示在k的最高位上是1（否则k的最高位那个1是怎么得到的）。这时ai^k&lt;ai一定成立。 则我们可以将ai改变成ai’=ai^k，此时a1^a2^…^ai’^…^an=a1^a2^…^an^k=0 HDOJ1907&amp;&amp;POJ3480&amp;ZOJ3113 John [ANTI-SG]必胜策略： sg值为0 且 全为孤单堆； sg值不为0 且 不全为孤单堆； NP暴力打表||找规律HDOJ1525&amp;POJ2348 Euclid’s Game [找规律博弈]注意第一次出现a/b&gt;1的位置为必胜 HDOJ1564 Play a game [找规律]（重点是打表的方法，N P定理）打表发现奇偶性规律 HDOJ1404 Digital Deletions [SG博弈]（暴力打表，NP定理）老实说，这个表不太好打。从P-&gt;N一种是在让某一位增加；另一种是在后面补0 裸求sg值HDOJ3032 Nim or not Nim? [找规律]SG打表重点是sg函数的求法，把一堆变成两堆，有嵌套的感觉。 HDOJ1729 Stone Game [SG博弈]这题我开始打了个表，，什么规律都没找出来，还是得靠分析，，可我不会啊。。。。 我的理解：可以先模拟一下，初始为（27,2），子递归状态为（4,2）然后返回2，结束。然后我从前往后推，A先拿2个，变为（27,4）状态，然后无论B怎么拿都无法拿完，所以B很保守的只拿一个，变为（27,5）状态，然后A轻松拿完；所以A获胜了。所以我的理解是子递归状态返回值的意义在于 先手能否成功到达必败点，让后手必败。 那么对于这题对于每一堆，放石子放满就想当于满的时候取s-c个，反向只是让我理解题意更深。 首先我们知道（S，S）这个局面是必败局面。 对于每一堆能加的数量有限，而当c的值（大于或者等于）D=sqrt(s) 或者 D=sqri（s）+1的时候就可以一次完成，就是说可以从当前局面到达（S，S）的局面，所以当前局面是必胜局面。 而这种情况下，你能造成的局面有集合A={0,1,2,…,s-c-1}；因为你可以去s-c，s-c-1，s-c-2，…..，1；那么对应mex(x)函数（即A中未出现的最小的一个数字），那么自然该局面的SG值就是s-c了； 另外当c的值小于D的时候，是不可能一下子加满的，因为c*c+c绝对是小于s的；那么小于D的局面一定能够是必输的吗？很显然不是的。 对于（S，D-1）这个局面，一定是必输，因为他能到的局面都是必胜！现在c小于D，那么如果（S，C）这个局面能到（S，D）；就代表这个局面是必胜的。所以现在SG值要在新集合（D，C）中求，而求法与上面的相同求新的D，所以可以用递归函数：当C&gt;D时，返回（S-C） 差不多就是这样。 其实D = sqrt(s);这里算是个加速，要不然就要：while(d*d+d &lt; S) d++;这样会很慢的。 思路：这题明显的sg函数。可惜我纠结了半天没想起思路来。设当前的箱子容量为si，求出一个t满足：t + t * t &lt; si，若是当前箱子里有ci颗石头， ci &gt; t 则必胜； ci == t 则必败； ci &lt; t不可立即断定，将t作为si递归调用函数。 当满足ci &gt; t时，return si - ci 作为当前状况的sg值。因为： 当ci在si点时，为有向图的端点，出度为0，也就是必败点，所以sg值为0； 当ci 位于si - 1时，ci的端点可能的sg值构成的凑集为{0}，所以当前sg值 为1； 当ci 位于si - 2 时，ci的端点可能的sg值构成的凑集为{0， 1}，所以当前的sg值为2； 可得，ci地点地位的sg值为si - ci； [TopCoder]SRM 561 DIV1 500：CirclesGame题意：给你n&lt;=50个不相交的圆（可能包含）。Alice 和Bob博弈，Alice先手，每次每人都可以选择一个没有红点的圆，在圆内放置一个红点，最后没法放红点的一方失败。 算法分析：圆与圆没有相交，故可以把每个圆看成一个结点，直接包含看成点与点之间的边，于是得到一个森林。原题变成在这个森林里博弈，每次选取一个结点，可以干掉他和他的所有祖先结点，干掉最后一个点的获胜。首先我们来考虑每颗树的sg函数。我们可以选择这棵树上任意一个结点操作，去掉这个结点以及其祖先结点后剩下的树的sg函数取异或便是当前操作所得状态的sg值，去掉这些sg值，剩下sg值的最小值即为这棵树的sg函数（看不懂的先好好学学博弈论）。求出每颗树的sg函数，最后取异或便是最终的sg函数，结果不等于0先手胜否则后手胜。 （这题不太好写，子状态神马递归容易出错） starcaseHDOJ3389 Game [Staircase Nim]变形要注意这类博弈的特点：一定是奇堆移动到偶堆，偶堆移动到奇堆。 题意：有N堆石子，每堆石子都有一定的石子数，Alice和Bob轮流玩一个游戏，游戏的规则是，每回合一个人可以选择1-n堆石子中的某一堆进行操作，操作是：假设选择操作的那堆石子的编号为A，现在还要选择一堆石子B，满足B&lt;A &amp;&amp; (A+B)%2==1 &amp;&amp; (A+B)%3==0，然后可以将A中至少一颗石子移到B中去，第一个不能进行合法操作的人输，问谁能赢。 思路：这是一个阶梯博弈的题目，首先我们可以发现，只有1 ，3 ，4 三个数是没有前缀的， 也就是terminal状态，其余的每个状态我们都可以计算出每个编号到这几个terminal的步数（当然有的编号的步数并不唯一，但是奇偶性是唯一的）。接下去我们就会发现，每次从一个奇数步的点，一定是要移到到 一个偶数步的点上去，也就是说每次只能移到奇数步，这个通过编号自身的奇偶性就可以证明了。这样就转化为了阶梯博弈的类型了，我们只需要关注奇数步编号出的石子的数量就可以了，如果奇数步编号处的石子的Nim和为0，则必败，不为0则必胜。接下去我们就简单地证明一下这个策略：如果移动的是奇数步位置的石子，则一定是移动到偶数步的位置，这时候我们只需要按照Nim博弈的必胜策略进行游戏就可以赢；如果移动的是偶数步数编号位置的石子，则移动是移动到奇数步的位置，这时候我们只需要将刚刚移动过来的石子移动到下一个偶数步位置，原来的Nim局面并没有变化，变化的只是偶数步石子的数量。这样我们就证明了原游戏可以转化为Nim游戏。 POJ1704 Georgia and Bob [阶梯博弈] (下面一题是这个的加强版，直接把这种最纯粹的看做模型)我们把棋子按位置升序排列后，从后往前把他们两两绑定成一对。如果总个数是奇数，就把最前面一个和边界（位置为0）绑定。在同一对棋子中，如果对手移动前一个，你总能对后一个移动相同的步数，所以一对棋子的前一个和前一对棋子的后一个之间有多少个空位置对最终的结果是没有影响的。于是我们只需要考虑同一对的两个棋子之间有多少空位。这样一来就成了N堆取石子游戏了. HDOJ4315 Climbing the Hill [阶梯博弈] （有待提高）这题压力山大，看了好久： 此题的简化版本是不考虑King的存在，双方一直走到不能走的一方为负。此时的解法是根据人数的奇偶性：把人从上顶向下的位置记为a1,a2,…an, 如果为偶数个人，则把a(2i-1)和a(2i)之间的距离当做一个Nim堆，变成一共n/2堆的Nim游戏；如果为奇数个人，则把山顶到a1的距离当做一个Nim堆，a(i2)到a(i2+1)的距离当做Nim堆，一共(n+1)/2堆。 考虑King的情况和上述版本几乎一致，只要把King当作普通人一样处理即可。除了两种特殊情况：1. 当King是第一个人时，Alice直接胜 2. 当King是第二个人且一共有奇数个人时，第一堆的大小需要减1。 题意如上图所示：有 n 个球分别在 n 个不同的位置，Alice 和 Bob 依次选择一个球向上移动，上面有球不能越过，谁最后把红球移出谁就赢！ 分析1、n 为偶数时：问题简化一下，假设全都是黄球，谁把最后一个球移出谁就赢（a1,a2） (a3,a4) …… ( a(2n-1) , a(2n) ) ……（a(n-1),an）其中第 i 个球与第 i+1 个球是相邻的，i 为基数，谁面对这个状态谁就必输。理由很简单，先手移动第 i 个球，后手移动第 i+1 个球，使之仍然保持必赢状态。回到原问题谁先移出红球谁就赢，假设红球不是第一个球（因为第一个球Alice直接就赢了）很显然如果红球在偶数位置后手必赢，如果在基数 i 位置，则只需将 第 i-1 个球移到第一个位置就ok了。所以与红球位置无关。至于产生这个状态（a1,a2） (a3,a4) …… ( a(2n-1) , a(2n) ) ……（a(n-1),an），那么就是简单的 Nim问题了2、n 为基数时：假设红球是第1、2个球。（a1） (a2,a3)（a4,a5）…… (a(2n),a(2n+1)) …… (a(n-1),an) 谁面对这个状态必赢！理由是先手直接把 a1 取走然后就变成上面的情况了，如果红球在第 2 个位置那么就是必输状态。 与staircase的联系：对于这个题目，从后向前两两划分成一组，组内相当于奇数阶梯上的石子，组间相当于偶数阶梯上的石子，移动组内的前面石子一定能够通过移动当前组的后面石子相同步数达到平衡态，移动组内后面的石子一定能够通过移动其他组后面石子达到平衡态，具体因为King的原因需要处理细节，上面已经说清楚了，不再赘述。 翻硬币游戏HDOJ3537 Daizhenyang’s Coin[翻硬币游戏]SG打表 （待解决）这题表我是打出来了，规律没找出来（注意还要对编号排序判重） HDOJ3951 Coin Game [找规律]题意给你n个硬币排成一圈，编号1-n,只能翻转连续的1~k个的硬币。翻最后一枚硬币者赢。 思路博弈 若k=1,则一次只能去翻一枚，奇数先手赢，偶数后手赢。 若k&gt;1: 先手一次翻完，先手赢； 先手不能翻完，第一次必定断环。只要后手一次翻完，或将其分为相等数量的两段， 之后先手怎么操作后手就怎么操作，后手必赢。 树&amp;&amp;删边HDOJ3094 A tree game[有向无环树形图SG博弈]最基础的删边 HDOJ3197 Game[树形SG博弈]砍树树的删边游戏，把多棵树的根异或起来就行了 HDOJ3590 PP and QQ[树的删边游戏+ANTI-SG]先手必胜当且仅当 游戏的SG函数不为0且游戏中某个单一游戏的SG函数大于1 游戏的SG函数为0且游戏中没有单一游戏的SG函数大于1 POJ3710 Christmas Game[无向图删边]Tarjan算法找出环，处理环之后，便是经典的删边游戏。拥有奇数条边的环可简化为一条边，偶数条边的环可简化为一个节点。]]></content>
      <categories>
        <category>Game theory</category>
      </categories>
      <tags>
        <tag>Nim</tag>
        <tag>SG</tag>
      </tags>
  </entry>
</search>
