<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[行存储和（HBase）列存储的区别]]></title>
    <url>%2F2018%2F07%2F11%2FRow-based-storage%2F</url>
    <content type="text"><![CDATA[原理 Row-based storage stores atable in a sequence of rows Column-based storage storesa table in a sequence of columns 优缺点行式存储下一张表的数据都是放在一起的，但列式存储下都被分开保存了。所以它们就有了如下这些优缺点： 列存储为什么快 减少了磁盘IO 随机读变成了连续读]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Hbase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Huffman-Tree]]></title>
    <url>%2F2018%2F07%2F11%2FHuffman-Tree%2F</url>
    <content type="text"><![CDATA[概览给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。 特点哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。 构造方法假设有n个权值，则构造出的哈夫曼树有n个叶子结点，n个权值分别设为 w1、w2、…、wn 将w1、w2、…，wn看成是有n 棵树的森林(每棵树仅有一个结点) 在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和 从森林中删除选取的两棵树，并将新树加入森林 重复(2)、(3)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树 注意为了使得到的哈夫曼树的结构尽量唯一，通常规定生成的哈夫曼树中每个结点的左子树根结点的权小于等于右子树根结点的权 应用在数据通信中，让使用频率高的用短码，使用频率低的用长码，以优化整个报文编码]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Huffman Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hash indexes and B-Trees]]></title>
    <url>%2F2018%2F07%2F11%2FB-Trees%2F</url>
    <content type="text"><![CDATA[Hash IndexesBitcaskDeleting records If you want to delete a key and its associated value, you have to append a special deletion record to the data file (sometimes called a tombstone). When log segments are merged, the tombstone tells the merging process to discard any previous values for the deleted key. Crash recovery you can restore each segment’s hash map by reading the entire segment file from beginning to end and noting the offset of the most recent value for every key as you go along. However, that might take a long time if the segment files are large, which would make server restarts painful. Bitcask speeds up recovery by storing a snapshot of each segment’s hash map on disk, which can be loaded into memory more quickly. Concurrency control As writes are appended to the log in a strictly sequential order, a common implementation choice is to have only one writer thread. Data file segments are append-only and otherwise immutable, so they can be read concurrently by multiple threads. append-only design turns out to be good for several reasons: Appending and segment merging are sequential write operations, which are generally much faster than random writes Concurrency and crash recovery are much simpler if segment files are append- only or immutable. For example, you don’t have to worry about the case where a crash happened while a value was being overwritten, leaving you with a file con‐ taining part of the old and part of the new value spliced together. 合并操作能使有用的数据文件更加紧凑 limitations The hash table must fit in memory, so if you have a very large number of keys, you’re out of luck. In principle, you could maintain a hash map on disk, but unfortunately it is difficult to make an on-disk hash map perform well. It requires a lot of random access I/O Range queries are not efficient. SSTables and LSM-TreesSSTable(Sorted String Table) sequence of key-value pairs is sorted by key each key only appears once within each merged segment fileSSTable 优势 Merging segments用了归并排序，保证新合并的segment依然有序，注意当多个segment出现相同的key时，取most recent segment In order to find a particular key in the file, you no longer need to keep an index of all the keys in memory. 取而代之的是一个稀疏的索引You still need an in-memory index to tell you the offsets for some of the keys, but it can be sparse 支持range query disk writes are sequential the LSM-tree can support remarkably high write throughputConstructing and maintaining SSTables When a write comes in, add it to an in-memory balanced tree data structure (for example, a red-black tree). This in-memory tree is sometimes called a memtable. When the memtable gets bigger than some threshold, write it out to disk as an SSTable file In order to serve a read request, first try to find the key in the memtable, then in the most recent on-disk segment, then in the next-older segment, etc. From time to time, run a merging and compaction process in the background to combine segment files and to discard overwritten or deleted values This scheme works very well. It only suffers from one problem: if the database crashes, the most recent writes (which are in the memtable but not yet written out to disk) are lost. In order to avoid that problem, we can keep a separate log on disk to which every write is immediately appended, just like in the previous section. That log is not in sorted order, but that doesn’t matter, because its only purpose is to restore the memtable after a crash. Every time the memtable is written out to an SSTable, the corresponding log can be discarded. Performance optimizations 当查找一个不存在的key时，首先去memtable找，然后从近到远依次找segment，所以为了避免这种情况发生，storage engines often use additional Bloom filters B-TreesConstructing log-structured indexes 将数据拆分成一个个大小可变的segment，并且能够满足顺序写，与之相比的是B-Trees将数据拆分成大小固定的blocks or pages, traditionally 4 KB in size (sometimes bigger), 一次只能读或者写一个page 一个page就是树的一个节点，每个节点指向多个儿子，节点的儿子数量被称为branching factor 当加入一个key的时候，如果符合条件的page空间被占满，这时这个page会被拆分成2个page，然后再更新他们的parent指针Making B-trees reliable write-ahead log (WAL, also known as a redo log)This is an append-only file to which every B-tree modification must be written before it can be applied to the pages of the tree itself, When the data‐base comes back up after a crash, this log is used to restore the B-tree back to a consistent state concurrency control is required if multiple threads are going to access the B-tree at the same time, 此时需要用锁B-tree optimizations Instead of overwriting pages and maintaining a WAL for crash recovery, some databases (like LMDB) use a copy-on-write scheme. 改动过的page会存在另外一个地方，并且它的父亲page会指向这个新儿子 不用存整个key的名称，只存能标识它的‘缩写’，这样可以节约空间，增加一个page的branching factor，从而缩小depth 存在兄弟指针，保证顺序遍历key的时候不用回到父节点 当大范围查询的时候，直接顺序遍历叶子节点Comparing B-Trees and LSM-TreesAs a rule of thumb,LSM-trees are typically faster for writes,whereas B-trees are thought to be faster for reads one write to the database resulting in multiplewrites to the disk over the course of the database’s lifetime—is known as write amplification. LSM-trees 能维持更高的写吞吐量，一部分是因为更小的write amplification，另一部分是因为顺序写真实他妈快啊]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>B-tree</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Suffix Tree 后缀数组]]></title>
    <url>%2F2013%2F03%2F28%2Fsuffix-tree%2F</url>
    <content type="text"><![CDATA[前言这是13年3月28日的文章，那时的我在机房熬了一天一夜翻来覆去看罗穗骞的代码，最后才把这个后缀数组给整明白了，故有此文现在的我回想那过去的岁月，难免唏嘘不已，今时今日借整理此文，以缅怀那过去的岁月吧！原文链接 声明我的模板是根据 罗穗骞 和 网上一模板 相结合改编而来，层次更加分明，数组名称的选择是根据用途来定义的，总的来说应该更好理解一些先声明一些概念： k-后缀数组：我这里用的是 sa[ ] ( k ) k-名次数组：我这里用的是 rank[ ] ( k ) 思路知道rank[ ] (1) 先求出sa[ ] (1)，然后根据 sa[ ] (1) 和 rank[ ] (1) 调用sorting函数求出 sa[ ] (2)，再求出rank[ ] (2) 等等 总的过程是rank[ ] (1)—-&gt;sa[ ] (1) —&gt;rank[ ] (2) —&gt; sa[ ] (2) —&gt; rank[ ] (k) —-&gt;sa[ ] (k) Hint 我的数组小标全是从1开始的，程序运行前一定要初始化函数ini() 其它该有的东西都在代码里，建议一边看代码下面的图，一边理解！ 模板代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;#define N 3000//处理完成之后下标都是从1开始char s[N];//存原始数据int sum[N], rank[2*N], trank[2*N];//sum用来基数排序；trank === temp-rankint sa[N], tsa[N]; //这里tsa[]用来保存第二关键字排序后的结果int Top, n; //Top基数排序出现的极大值void ini() //初始化&#123; n=strlen(s); memset(sum,0,sizeof(sum)); memset(rank,0,sizeof(rank)); memset(sa,0,sizeof(sa)); Top=128;&#125;void sorting(int k)&#123; int p = 1; //利用sa排序第二关键字，求出tsa for(int i = n-k+1; i &lt;= n; i++) tsa[p++]=i; //超出范围的下标按下标顺序置其名次为最低 for(int i = 1; i &lt;= n; i++) if(sa[i]&gt;=k+1) tsa[p++]=sa[i]-k; //按sa排名从小到大遍历，如果排名为i的某后缀(sa[i])位置在k后面，那么这个后缀肯定会在第二关键字排序 //(tsa[])中出现并且排在比较靠前的位置，这个后缀对应tsa[]中的位置为sa[i]-k memset(sum,0,sizeof(sum)); for(int i = 1; i &lt;= n; i++)sum[rank[i]]++; for(int i = 1; i &lt;= Top; i++)sum[i]+=sum[i-1]; for(int i = n; i &gt; 0; i--)sa[sum[rank[tsa[i]]]--]=tsa[i];//这句话应该是关键 //如果把tsa[i]换成i，那么就是对rank[i]按第一关键字排序求sa[]，事实上这段程序也是这样， //不过把i换成tsa[i]后会多一个功能，就是按第一关键字排序rank相同的情况下，会按第二关键字排， //这也正符合我们最终要求的sa[](2k)。具体方法是从tsa[n]到tsa[1]，让在第二关键字排名靠后的优先 //取sum较大的，取一次，sum--，如果后边第二关键字排名靠前的某后缀在第一关键字下rank和它相同， //那么它的sum就较小，在sa中排名就会靠前，服从排序规律！&#125;void get_sa()&#123; int p; for(int i = 0; i &lt; n; i++) rank[i+1]=s[i]; //仔细想一下，其实此时rank就是rank[](1); for(int i = 1; i &lt;= n; i++) sum[rank[i]]++; for(int i = 1; i &lt;= Top; i++) sum[i]+=sum[i-1]; //sum[i] means the number of the &lt;= rank[i]; for(int i = n; i &gt; 0; i--) sa[sum[rank[i]]--]=i; //sa[](1)构造完成 for(int k = 1; k &lt;= n; k&lt;&lt;=1) &#123; sorting(k); //由sa[](k)和rank[](k) 求 sa[](2k) //求rank[](2k) trank[sa[1]]=1; p=1; for(int i = 2; i &lt;= n; i++) &#123; if((rank[sa[i]]!=rank[sa[i-1]])||(rank[sa[i]+k]!=rank[sa[i-1]+k]))p++; trank[sa[i]]=p; &#125; for(int i = 1; i &lt;= n; i++)rank[i]=trank[i]; if(p&gt;=n)break; //rank[1,2……n]已经唯一了，即后缀大小已经唯一确定了，不需要继续执行了 Top=p;//下次基数排序的最大值 &#125;&#125;int height[N];void get_height()&#123; for(int i = 1, j = 0; i &lt;= n; i++) &#123; if(rank[i]==1)continue; for(;s[i+j-1]==s[sa[rank[i]-1]+j-1];)j++;//i从1开始，所以在原串中要-1 height[rank[i]]=j; if(j&gt;0)j--; &#125;&#125; int *RMQ=height;int mm[N];int best[20][N];void initRMQ(int n)&#123; int i,j,a,b; for(mm[0]=-1,i=1; i&lt;=n; i++) mm[i]=((i&amp;(i-1))==0)?mm[i-1]+1:mm[i-1]; for(i=1; i&lt;=n; i++)best[0][i]=i; for(i=1; i&lt;=mm[n]; i++)for(j=1; j&lt;=n+1-(1&lt;&lt;i); j++) &#123; a=best[i-1][j]; b=best[i-1][j+(1&lt;&lt;(i-1))]; if(RMQ[a]&lt;RMQ[b])best[i][j]=a; else best[i][j]=b; &#125;&#125;int askRMQ(int a,int b)&#123; int t; t=mm[b-a+1]; b-=(1&lt;&lt;t)-1; a=best[t][a]; b=best[t][b]; return RMQ[a]&lt;RMQ[b]?a:b;&#125;//求sufix(a)与sufix(b)的最长公共前缀长度，用上面的RMQ优化int lcp(int a,int b) //这里的a,b是字符串当中的位置，注意要从1开始&#123; int t; a=rank[a],b=rank[b]; if(a&gt;b) &#123; t=a; a=b; b=t; &#125; return height[askRMQ(a+1,b)];&#125; h[i] &gt;= h[i-1]-1的证明设suffix(k)是排在suffix(i-1)前一位的后缀，则它们的最长公共前缀显然是h[i-1]。那么，suffix(k+1)显然将排在suffix(i)的前面。并且，suffix(k+1)&amp;suffix(i) 相对于 suffix(k)&amp;suffix(i-1)来说就是同时去掉了第一位，即少了一位的匹配数。所以suffix(i)和前一名次后缀的最长公共前缀至少是h[i-1]-1 为什么是 至少h[i-1]-1的理解根据上面的证明我们可以得到suffix(k+1)&amp;suffix(i) == h[i-1]-1又因为suffix(k+1)显然将排在suffix(i)的前面所以 LCP(k+1,i) = h[i-1]-1 =min{ LCP(j-1, j) |k+1 ≤j ≤i } （LCP Theorem）&lt;= h[i]@(数据结构)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Suffix Tree</tag>
      </tags>
  </entry>
</search>
