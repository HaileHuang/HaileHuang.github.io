<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[React 注意事项]]></title>
    <url>%2F2018%2F07%2F20%2FReact-hints%2F</url>
    <content type="text"><![CDATA[用Functional Component 代替 Stateful ComponentStateful Component12345class Avatar extends React.Component &#123; render() &#123; return &lt;img src=&#123;this.props.url&#125; /&gt;; &#125;&#125;Functional Component1234// simplified version of our real componentconst Avatar = (props) =&gt; &#123; return &lt;img src=&#123;props.url&#125; /&gt;;&#125;Functional Component 实际上就是一个JS的function，它返回一些元素但是，你可能会认为Functional Component可能会避开像mounting / unmounting这些生命周期事件，那你就傻逼了下面是React作者的twitter This pattern is designed to encourage the creation of these simple components that should comprise large portions of your apps. In the future, we’ll also be able to make performance optimizations specific to these components by avoiding unnecessary checks and memory allocations. 用调用函数的方式加载Component原文链接123456789101112131415161718192021 ReactDOM.render( &lt;div&gt;- &lt;Avatar url=&#123;avatarUrl&#125; /&gt;+ &#123;Avatar(&#123; url: avatarUrl &#125;)&#125; &lt;div&gt;&#123;commentBody&#125;&lt;/div&gt; &lt;/div&gt;, mountNode ); // Compiled JavaScript ReactDOM.render(React.createElement( 'div', null,- React.createElement(Avatar, &#123; url: avatarUrl &#125;),+ Avatar(&#123; url: avatarUrl &#125;), React.createElement( 'div', null, commentBody ) ), mountNode);像上面代码展示的那样用+的方式（直接调用函数）代替 JSX tags 的方式 来加载Avatar这个Functional Component，我们会省略掉一个React.createElement的调用 和 它里面的所有的React生命周期事件，我们再也不需要等待React Team 去优化Functional Component了。实验证明，使用直接加载Functional Component的方式，会加速45% 阻止冒泡React自己实现了一套时间代理机制叫做SyntheticEvent，一个基于浏览器原生事件的跨浏览器实现。它拥有和浏览器原生事件一样的接口，包括stopPropagation()和preventDefault()，除了那些所有浏览器功能一样的事件而例如jQuery的事件代理是可以在React内部并行的所以当你要阻止一个事件冒泡时，很可能你需要像下面这样写：1234stopPropagation: function(e)&#123; e.stopPropagation(); //阻止React冒泡 e.nativeEvent.stopImmediatePropagation();//阻止原生js冒泡&#125;, 不要忘了React KeyReact will determine whether it is the same component or not based on keyNew component on the same level as old one? Would you kindly change a key? 不要在render里call ActionThe render() function should be pure, meaning that it does not modify component state.If you in render function call Action an return some data to setState,This will cause render a page multiple times or endless-loop. passing the component initial state a prop an anti-pattern这其实是一种props和state混用的情况，不建议在 initial state 根据传入的 props 来赋值当然最好是保证组件stateless React setState setState不会马上改变state，是异步操作 setState总会触发render除非shouldComponentUpdate返回false]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>hints</tag>
        <tag>Functional Component</tag>
        <tag>SyntheticEvent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redux]]></title>
    <url>%2F2018%2F07%2F19%2FRedux%2F</url>
    <content type="text"><![CDATA[一个JS状态管理框架 不需要redux 用户的使用方式非常简单 用户之间没有协作 不需要与服务器大量交互，也没有使用 WebSocket 视图层（View）只从单一来源获取数据 需要redux 某个组件的状态，需要共享 某个状态需要在任何地方都可以拿到 一个组件需要改变全局状态 一个组件需要改变另一个组件的状态 特性Single Source of Truth 可预测性 纯函数更新 StoreReducer 函数最重要的特征是，它是一个纯函数。也就是说，只要是同样的输入，必定得到同样的输出。纯函数是函数式编程的概念，必须遵守以下一些约束 不得改写参数 不能调用系统 I/O 的API 不能调用Date.now()或者Math.random()等不纯的方法，因为每次会得到不一样的结果 由于 Reducer 是纯函数，就可以保证同样的State，必定得到同样的 View。但也正因为这一点，Reducer 函数里面不能改变 State，必须返回一个全新的对象 StoreStore 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 StoreRedux 提供createStore这个函数，用来生成 Store12import &#123; createStore &#125; from &apos;redux&apos;;const store = createStore(Reducer); store.getState()Store对象包含所有数据。如果想得到某个时点的数据，就要对 Store 生成快照。这种时点的数据集合，就叫做 State。当前时刻的 State，可以通过store.getState()拿到 store.dispatch()store.dispatch()是 View 发出 Action 的唯一方法1234567import &#123; createStore &#125; from &apos;redux&apos;;const store = createStore(fn);store.dispatch(&#123; type: &apos;ADD_TODO&apos;, payload: &apos;Learn Redux&apos;&#125;); 上面代码中，store.dispatch接受一个 Action 对象作为参数，将它发送出去结合 Action Creator，这段代码可以改写如下:1store.dispatch(addTodo(&apos;Learn Redux&apos;)); store.subscribe()Store 允许使用store.subscribe方法设置监听函数，一旦 State发生变化，就自动执行这个函数显然，只要把 View 的更新函数（对于 React 项目，就是组件的render方法或setState方法）放入listen，就会实现 View 的自动渲染 actionState 的变化，会导致 View 的变化。但是，用户接触不到 State，只能接触到 View。所以，State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发生变化了Action 是一个对象。其中的type属性是必须的，表示 Action 的名称。其他属性可以自由设置。1234const action = &#123; type: &apos;ADD_TODO&apos;, payload: &apos;Learn Redux&apos;&#125;; 上面代码中，Action 的名称是ADD_TODO，它携带的信息是字符串Learn Redux。可以这样理解，Action 描述当前发生的事情。改变 State 的唯一办法，就是使用 Action。它会运送数据到 Store reducerStore 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 ReducerReducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State。1234const reducer = function (state, action) &#123; // ... return new_state;&#125;; bindActionCreators就是将action和dispatch action 结合起来返回一个函数，这个函数实现了两个功能 生成action dispatch这个action 总结首先，用户发出 Action1store.dispatch(action) 然后，Store 自动调用 Reducer，并且传入两个参数：当前 State 和收到的 Action。 Reducer 会返回新的 State1let nextState = todoApp(previousState, action) State 一旦有变化，Store 就会调用监听函数12// 设置监听函数store.subscribe(listener); listener可以通过store.getState()得到当前状态。如果使用的是 React，这时可以触发重新渲染 View1234function listerner() &#123; let newState = store.getState(); component.setState(newState); &#125; example123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import React from "react";import &#123; createStore, combineReducers, bindActionCreators&#125; from "redux";function run() &#123; // Store initial state const initialState = &#123; count: 0 &#125;; // reducer const counter = (state = initialState, action) =&gt; &#123; switch (action.type) &#123; case "PLUS_ONE": return &#123; count: state.count + 1 &#125;; case "MINUS_ONE": return &#123; count: state.count - 1 &#125;; case "CUSTOM_COUNT": return &#123; count: state.count + action.payload.count &#125;; default: break; &#125; return state; &#125;; const todos = (state = &#123;&#125;) =&gt; state; // Create store const store = createStore( combineReducers(&#123; todos, counter &#125;) ); // Action creator function plusOne() &#123; // action return &#123; type: "PLUS_ONE" &#125;; &#125; function minusOne() &#123; return &#123; type: "MINUS_ONE" &#125;; &#125; function customCount(count) &#123; return &#123; type: "CUSTOM_COUNT", payload: &#123; count &#125; &#125;; &#125; plusOne = bindActionCreators(plusOne, store.dispatch); store.subscribe(() =&gt; console.log(store.getState())); // store.dispatch(plusOne()); plusOne(); store.dispatch(minusOne()); store.dispatch(customCount(5));&#125;export default () =&gt; ( &lt;div&gt; &lt;button onClick=&#123;run&#125;&gt;Run&lt;/button&gt; &lt;p&gt;* 请打开控制台查看运行结果&lt;/p&gt; &lt;/div&gt;);]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-Context]]></title>
    <url>%2F2018%2F07%2F19%2Freact-context%2F</url>
    <content type="text"><![CDATA[在一个典型的 React 应用中，数据是通过 props 属性由上向下（由父及子）的进行传递的，但这对于某些类型的属性而言是极其繁琐的（例如：地区偏好，UI主题），这是应用程序中许多组件都所需要的。 Context 提供了一种在组件之间共享此类值的方式，而不必通过组件树的每个层级显式地传递 props 何时使用 ContextContext 设计目的是为共享那些被认为对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言。例如，在下面的代码中，我们通过一个“theme”属性手动调整一个按钮组件的样式：1234567891011121314151617181920function ThemedButton(props) &#123; return &lt;Button theme=&#123;props.theme&#125; /&gt;;&#125;// 中间组件function Toolbar(props) &#123; // Toolbar 组件必须添加一个额外的 theme 属性 // 然后传递它给 ThemedButton 组件 return ( &lt;div&gt; &lt;ThemedButton theme=&#123;props.theme&#125; /&gt; &lt;/div&gt; );&#125;class App extends React.Component &#123; render() &#123; return &lt;Toolbar theme="dark" /&gt;; &#125;&#125;使用 context, 我可以避免通过中间元素传递 props：123456789101112131415161718192021222324252627282930// 创建一个 theme Context, 默认 theme 的值为 lightconst ThemeContext = React.createContext('light');function ThemedButton(props) &#123; // ThemedButton 组件从 context 接收 theme return ( &lt;ThemeContext.Consumer&gt; &#123;theme =&gt; &lt;Button &#123;...props&#125; theme=&#123;theme&#125; /&gt;&#125; &lt;/ThemeContext.Consumer&gt; );&#125;// 中间组件function Toolbar(props) &#123; return ( &lt;div&gt; &lt;ThemedButton /&gt; &lt;/div&gt; );&#125;class App extends React.Component &#123; render() &#123; return ( &lt;ThemeContext.Provider value="dark"&gt; &lt;Toolbar /&gt; &lt;/ThemeContext.Provider&gt; ); &#125;&#125; 改变Context内state的状态，所有的consumer随之更新实现点击切换语言来更新语言 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import React from "react";const enStrings = &#123; submit: "Submit", cancel: "Cancel"&#125;;const cnStrings = &#123; submit: "提交", cancel: "取消"&#125;;const LocaleContext = React.createContext(enStrings);class LocaleProvider extends React.Component &#123; state = &#123; locale: cnStrings &#125;; toggleLocale = () =&gt; &#123; const locale = this.state.locale === enStrings ? cnStrings : enStrings; this.setState(&#123; locale &#125;); &#125;; render() &#123; return ( &lt;LocaleContext.Provider value=&#123;this.state.locale&#125;&gt; &lt;button onClick=&#123;this.toggleLocale&#125;&gt; 切换语言 &lt;/button&gt; &#123;this.props.children&#125; &lt;/LocaleContext.Provider&gt; ); &#125;&#125;class LocaledButtons extends React.Component &#123; render() &#123; return ( &lt;LocaleContext.Consumer&gt; &#123;locale =&gt; ( &lt;div&gt; &lt;button&gt;&#123;locale.cancel&#125;&lt;/button&gt; &amp;nbsp;&lt;button&gt;&#123;locale.submit&#125;&lt;/button&gt; &lt;/div&gt; )&#125; &lt;/LocaleContext.Consumer&gt; ); &#125;&#125;export default () =&gt; ( &lt;div&gt; &lt;LocaleProvider&gt; &lt;div&gt; &lt;br /&gt; &lt;LocaledButtons /&gt; &lt;/div&gt; &lt;/LocaleProvider&gt; &lt;/div&gt;);]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>Context</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React lifecycle v16.3 changes]]></title>
    <url>%2F2018%2F07%2F19%2FReact-lifecycle%2F</url>
    <content type="text"><![CDATA[v16.3之前的lifecycle传统组件生命周期会导致一些不安全的编码实践，他们是： componentWillMount componentWillReceiveProps componentWillUpdate 这些生命周期方法经常被误解和滥用此外，我们预计他们的潜在滥用可能在异步渲染方面有更大的问题。因此，我们将在即将发布的版本中为这些生命周期添加一个“UNSAFE_”前缀 逐渐迁移的计划 16.3：为不安全生命周期引入别名UNSAFE_componentWillMount， UNSAFE_componentWillReceiveProps和UNSAFE_componentWillUpdate。 （旧的生命周期名称和新的别名都可以在此版本中使用。） 未来的16.x版本: 为componentWillMount，componentWillReceiveProps和componentWillUpdate启用弃用警告。 （旧的生命周期名称和新的别名都可以在此版本中使用，但旧名称会记录DEV模式警告。） 17.0: 删除componentWillMount，componentWillReceiveProps和componentWillUpdate。 （从现在开始，只有新的“UNSAFE_”生命周期名称将起作用。） v16.3lifecycle改动 We are adding the following lifecycle aliases: UNSAFE_componentWillMount, UNSAFE_componentWillReceiveProps, and UNSAFE_componentWillUpdate. (Both the old lifecycle names and the new aliases will be supported.) We are introducing two new lifecycles, static getDerivedStateFromProps and getSnapshotBeforeUpdate getDerivedStateFromProps12345class Example extends React.Component &#123; static getDerivedStateFromProps(nextProps, prevState) &#123; // ... &#125;&#125; 新的静态getDerivedStateFromProps生命周期在组件实例化以及接收新props后调用。它可以返回一个对象来更新state，或者返回null来表示新的props不需要任何state更新与componentDidUpdate一起，这个新的生命周期应该覆盖传统componentWillReceiveProps的所有用例 getSnapshotBeforeUpdate12345class Example extends React.Component &#123; getSnapshotBeforeUpdate(prevProps, prevState) &#123; // ... &#125;&#125; 新的getSnapshotBeforeUpdate生命周期在更新之前被调用（例如，在DOM被更新之前）。此生命周期的返回值将作为第三个参数传递给componentDidUpdate。 （这个生命周期不是经常需要的，但可以用于在恢复期间手动保存滚动位置的情况。）与componentDidUpdate一起，这个新的生命周期将覆盖旧版componentWillUpdate的所有用例 Examples初始化状态（Initializing state）这个例子展示了一个调用componentWillMount中带有setState的组件：1234567891011// Beforeclass ExampleComponent extends React.Component &#123; state = &#123;&#125;; componentWillMount() &#123; this.setState(&#123; currentColor: this.props.defaultColor, palette: 'rgb', &#125;); &#125;&#125;这种类型的组件最简单的重构是将状态初始化移动到构造函数或属性初始值设定项，如下所示：1234567// Afterclass ExampleComponent extends React.Component &#123; state = &#123; currentColor: this.props.defaultColor, palette: 'rgb', &#125;;&#125; 获取外部数据(Fetching external data)在componentDidMount中获取外部数据1234567891011121314151617181920212223242526272829// Afterclass ExampleComponent extends React.Component &#123; state = &#123; externalData: null, &#125;; componentDidMount() &#123; this._asyncRequest = asyncLoadData().then( externalData =&gt; &#123; this._asyncRequest = null; this.setState(&#123;externalData&#125;); &#125; ); &#125; componentWillUnmount() &#123; if (this._asyncRequest) &#123; this._asyncRequest.cancel(); &#125; &#125; render() &#123; if (this.state.externalData === null) &#123; // Render loading state ... &#125; else &#123; // Render real UI ... &#125; &#125;&#125; 添加事件监听(Adding event listeners )添加事件监听的推荐方式是使用componentDidMount生命周期12345678910111213141516171819202122232425262728293031323334353637// Afterclass ExampleComponent extends React.Component &#123; state = &#123; subscribedValue: this.props.dataSource.value, &#125;; componentDidMount() &#123; // Event listeners are only safe to add after mount, // So they won't leak if mount is interrupted or errors. this.props.dataSource.subscribe( this.handleSubscriptionChange ); // External values could change between render and mount, // In some cases it may be important to handle this case. if ( this.state.subscribedValue !== this.props.dataSource.value ) &#123; this.setState(&#123; subscribedValue: this.props.dataSource.value, &#125;); &#125; &#125; componentWillUnmount() &#123; this.props.dataSource.unsubscribe( this.handleSubscriptionChange ); &#125; handleSubscriptionChange = dataSource =&gt; &#123; this.setState(&#123; subscribedValue: dataSource.value, &#125;); &#125;;&#125; 基于props更新state以下是使用旧版componentWillReceiveProps生命周期基于新的道具值更新状态的组件示例123456789101112131415// Beforeclass ExampleComponent extends React.Component &#123; state = &#123; isScrollingDown: false, &#125;; componentWillReceiveProps(nextProps) &#123; if (this.props.currentRow !== nextProps.currentRow) &#123; this.setState(&#123; isScrollingDown: nextProps.currentRow &gt; this.props.currentRow, &#125;); &#125; &#125;&#125;尽管上面的代码本身并没有问题，但componentWillReceiveProps生命周期通常会被错误地用于解决问题。因此，该方法将被弃用。从版本16.3开始，更新state以响应props更改的推荐方法是使用新的静态getDerivedStateFromProps生命周期。 （生命周期在组件创建时以及每次收到新道具时调用）：12345678910111213141516171819202122// Afterclass ExampleComponent extends React.Component &#123; // Initialize state in constructor, // Or with a property initializer. state = &#123; isScrollingDown: false, lastRow: null, &#125;; static getDerivedStateFromProps(nextProps, prevState) &#123; if (nextProps.currentRow !== prevState.lastRow) &#123; return &#123; isScrollingDown: nextProps.currentRow &gt; prevState.lastRow, lastRow: nextProps.currentRow, &#125;; &#125; // Return null to indicate no change to state. return null; &#125;&#125; 调用外部回调函数(Invoking external callbacks)下面是一个在内部状态发生变化时调用外部函数的组件示例：1234567891011// Beforeclass ExampleComponent extends React.Component &#123; componentWillUpdate(nextProps, nextState) &#123; if ( this.state.someStatefulValue !== nextState.someStatefulValue ) &#123; nextProps.onChange(nextState.someStatefulValue); &#125; &#125;&#125;在异步模式下使用componentWillUpdate都是不安全的，因为外部回调可能会多次调用只更新一次。相反，应该使用componentDidUpdate生命周期，因为它保证每次更新只调用一次1234567891011// Afterclass ExampleComponent extends React.Component &#123; componentDidUpdate(prevProps, prevState) &#123; if ( this.state.someStatefulValue !== prevState.someStatefulValue ) &#123; this.props.onChange(this.state.someStatefulValue); &#125; &#125;&#125;props改变的副作用(Side effects on props change)与上述 事例类似，有时组件在props更改时会产生副作用12345678// Beforeclass ExampleComponent extends React.Component &#123; componentWillReceiveProps(nextProps) &#123; if (this.props.isVisible !== nextProps.isVisible) &#123; logVisibleChange(nextProps.isVisible); &#125; &#125;&#125;与componentWillUpdate一样，componentWillReceiveProps可能会多次调用但是只更新一次。出于这个原因，避免在此方法中导致的副作用非常重要。相反，应该使用componentDidUpdate，因为它保证每次更新只调用一次：12345678// Afterclass ExampleComponent extends React.Component &#123; componentDidUpdate(prevProps, prevState) &#123; if (this.props.isVisible !== prevProps.isVisible) &#123; logVisibleChange(this.props.isVisible); &#125; &#125;&#125; props改变时获取外部数据(Fetching external data when props change)以下是根据propsvalues提取外部数据的示例12345678910111213141516171819202122232425262728293031323334353637383940// Beforeclass ExampleComponent extends React.Component &#123; state = &#123; externalData: null, &#125;; componentDidMount() &#123; this._loadAsyncData(this.props.id); &#125; componentWillReceiveProps(nextProps) &#123; if (nextProps.id !== this.props.id) &#123; this.setState(&#123;externalData: null&#125;); this._loadAsyncData(nextProps.id); &#125; &#125; componentWillUnmount() &#123; if (this._asyncRequest) &#123; this._asyncRequest.cancel(); &#125; &#125; render() &#123; if (this.state.externalData === null) &#123; // Render loading state ... &#125; else &#123; // Render real UI ... &#125; &#125; _loadAsyncData(id) &#123; this._asyncRequest = asyncLoadData(id).then( externalData =&gt; &#123; this._asyncRequest = null; this.setState(&#123;externalData&#125;); &#125; ); &#125;&#125;此组件的推荐升级路径是将数据更新移动到componentDidUpdate中。在渲染新道具之前，您还可以使用新的getDerivedStateFromProps生命周期清除陈旧的数据：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// Afterclass ExampleComponent extends React.Component &#123; state = &#123; externalData: null, &#125;; static getDerivedStateFromProps(nextProps, prevState) &#123; // Store prevId in state so we can compare when props change. // Clear out previously-loaded data (so we don't render stale stuff). if (nextProps.id !== prevState.prevId) &#123; return &#123; externalData: null, prevId: nextProps.id, &#125;; &#125; // No state update necessary return null; &#125; componentDidMount() &#123; this._loadAsyncData(this.props.id); &#125; componentDidUpdate(prevProps, prevState) &#123; if (this.state.externalData === null) &#123; this._loadAsyncData(this.props.id); &#125; &#125; componentWillUnmount() &#123; if (this._asyncRequest) &#123; this._asyncRequest.cancel(); &#125; &#125; render() &#123; if (this.state.externalData === null) &#123; // Render loading state ... &#125; else &#123; // Render real UI ... &#125; &#125; _loadAsyncData(id) &#123; this._asyncRequest = asyncLoadData(id).then( externalData =&gt; &#123; this._asyncRequest = null; this.setState(&#123;externalData&#125;); &#125; ); &#125;&#125; 在更新之前读取DOM属性(Reading DOM properties before an update)下面是一个组件的例子，它在更新之前从DOM中读取属性，以便在列表中保持滚动位置123456789101112131415161718192021222324252627282930313233343536class ScrollingList extends React.Component &#123; listRef = null; previousScrollOffset = null; componentWillUpdate(nextProps, nextState) &#123; // Are we adding new items to the list? // Capture the scroll position so we can adjust scroll later. if (this.props.list.length &lt; nextProps.list.length) &#123; this.previousScrollOffset = this.listRef.scrollHeight - this.listRef.scrollTop; &#125; &#125; componentDidUpdate(prevProps, prevState) &#123; // If previousScrollOffset is set, we've just added new items. // Adjust scroll so these new items don't push the old ones out of view. if (this.previousScrollOffset !== null) &#123; this.listRef.scrollTop = this.listRef.scrollHeight - this.previousScrollOffset; this.previousScrollOffset = null; &#125; &#125; render() &#123; return ( `&lt;div&gt;` &#123;/* ...contents... */&#125; `&lt;/div&gt;` ); &#125; setListRef = ref =&gt; &#123; this.listRef = ref; &#125;;&#125;在上面的例子中，componentWillUpdate被用来读取DOM属性。但是，对于异步渲染，“render”阶段生命周期（如componentWillUpdate和render）与“commit”阶段生命周期（如componentDidUpdate）之间可能存在延迟。如果用户在这段时间内做了类似调整窗口大小的操作，则从componentWillUpdate中读取的scrollHeight值将失效。 解决此问题的方法是使用新的“commit”阶段生命周期getSnapshotBeforeUpdate。在数据发生变化之前立即调用该方法（例如，在更新DOM之前）。它可以将React的值作为参数传递给componentDidUpdate，在数据发生变化后立即调用它。123456789101112131415161718192021222324252627282930313233343536class ScrollingList extends React.Component &#123; listRef = null; getSnapshotBeforeUpdate(prevProps, prevState) &#123; // Are we adding new items to the list? // Capture the scroll position so we can adjust scroll later. if (prevProps.list.length &lt; this.props.list.length) &#123; return ( this.listRef.scrollHeight - this.listRef.scrollTop ); &#125; return null; &#125; componentDidUpdate(prevProps, prevState, snapshot) &#123; // If we have a snapshot value, we've just added new items. // Adjust scroll so these new items don't push the old ones out of view. // (snapshot here is the value returned from getSnapshotBeforeUpdate) if (snapshot !== null) &#123; this.listRef.scrollTop = this.listRef.scrollHeight - snapshot; &#125; &#125; render() &#123; return ( `&lt;div&gt;` &#123;/* ...contents... */&#125; `&lt;/div&gt;` ); &#125; setListRef = ref =&gt; &#123; this.listRef = ref; &#125;;&#125;]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>lifecycle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Diff算法]]></title>
    <url>%2F2018%2F07%2F18%2FReact-Diff%2F</url>
    <content type="text"><![CDATA[前言React 中最值得称道的部分莫过于 Virtual DOM 与 diff 的完美结合，特别是其高效的 diff 算法，让用户可以无需顾忌性能问题而”任性自由”的刷新页面，让开发者也可以无需关心 Virtual DOM 背后的运作原理，因为 React diff 会帮助我们计算出 Virtual DOM 中真正变化的部分，并只针对该部分进行实际 DOM 操作，而非重新渲染整个页面，从而保证了每次操作更新后页面的高效渲染，因此 Virtual DOM 与 diff 是保证 React 性能口碑的幕后推手 假设树中元素个数为n，最先进的算法 的时间复杂度为O(n3)React基于三点假设，实现了一个启发的O(n)算法 类型相同的节点总是生成同样的树，而类型不同的节点也总是生成不同的树 类型相同的兄弟节点可以被唯一标识 Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计 Diff算法tree diff两棵树只会对同一层次的节点进行比较 component diff 如果是同一类型的组件，按照原策略继续比较 virtual DOM tree 如果不是，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点 对于同一类型的组件，有可能其 Virtual DOM 没有任何变化，如果能够确切的知道这点那可以节省大量的 diff 运算时间，因此 React 允许用户通过 shouldComponentUpdate() 来判断该组件是否需要进行 diff element diff当节点处于同一层级时，React diff 提供了三种节点操作，分别为：INSERT_MARKUP（插入）、MOVE_EXISTING（移动）和 REMOVE_NODE（删除）可以根据key值进行优化 总结 React 通过制定大胆的 diff 策略，将 O(n3) 复杂度的问题转换成 O(n) 复杂度的问题 React 通过分层求异的策略，对 tree diff 进行算法优化 React 通过相同类生成相似树形结构，不同类生成不同树形结构的策略，对 component diff 进行算法优化 React 通过设置唯一 key的策略，对 element diff 进行算法优化 建议，在开发组件时，保持稳定的 DOM 结构会有助于性能的提升 建议，在开发过程中，尽量减少类似将最后一个节点移动到列表首部的操作，当节点数量过大或更新操作过于频繁时，在一定程度上会影响 React 的渲染性能]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>diff</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[行存储和（HBase）列存储的区别]]></title>
    <url>%2F2018%2F07%2F11%2FRow-based-storage%2F</url>
    <content type="text"><![CDATA[原理 Row-based storage stores atable in a sequence of rows Column-based storage storesa table in a sequence of columns 优缺点行式存储下一张表的数据都是放在一起的，但列式存储下都被分开保存了。所以它们就有了如下这些优缺点： 列存储为什么快 减少了磁盘IO 随机读变成了连续读]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Hbase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Huffman-Tree]]></title>
    <url>%2F2018%2F07%2F11%2FHuffman-Tree%2F</url>
    <content type="text"><![CDATA[概览给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。 特点哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。 构造方法假设有n个权值，则构造出的哈夫曼树有n个叶子结点，n个权值分别设为 w1、w2、…、wn 将w1、w2、…，wn看成是有n 棵树的森林(每棵树仅有一个结点) 在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和 从森林中删除选取的两棵树，并将新树加入森林 重复(2)、(3)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树 注意为了使得到的哈夫曼树的结构尽量唯一，通常规定生成的哈夫曼树中每个结点的左子树根结点的权小于等于右子树根结点的权 应用在数据通信中，让使用频率高的用短码，使用频率低的用长码，以优化整个报文编码]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Huffman Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hash indexes and B-Trees]]></title>
    <url>%2F2018%2F07%2F11%2FB-Trees%2F</url>
    <content type="text"><![CDATA[Hash IndexesBitcaskDeleting records If you want to delete a key and its associated value, you have to append a special deletion record to the data file (sometimes called a tombstone). When log segments are merged, the tombstone tells the merging process to discard any previous values for the deleted key. Crash recovery you can restore each segment’s hash map by reading the entire segment file from beginning to end and noting the offset of the most recent value for every key as you go along. However, that might take a long time if the segment files are large, which would make server restarts painful. Bitcask speeds up recovery by storing a snapshot of each segment’s hash map on disk, which can be loaded into memory more quickly. Concurrency control As writes are appended to the log in a strictly sequential order, a common implementation choice is to have only one writer thread. Data file segments are append-only and otherwise immutable, so they can be read concurrently by multiple threads. append-only design turns out to be good for several reasons: Appending and segment merging are sequential write operations, which are generally much faster than random writes Concurrency and crash recovery are much simpler if segment files are append- only or immutable. For example, you don’t have to worry about the case where a crash happened while a value was being overwritten, leaving you with a file con‐ taining part of the old and part of the new value spliced together. 合并操作能使有用的数据文件更加紧凑 limitations The hash table must fit in memory, so if you have a very large number of keys, you’re out of luck. In principle, you could maintain a hash map on disk, but unfortunately it is difficult to make an on-disk hash map perform well. It requires a lot of random access I/O Range queries are not efficient. SSTables and LSM-TreesSSTable(Sorted String Table) sequence of key-value pairs is sorted by key each key only appears once within each merged segment fileSSTable 优势 Merging segments用了归并排序，保证新合并的segment依然有序，注意当多个segment出现相同的key时，取most recent segment In order to find a particular key in the file, you no longer need to keep an index of all the keys in memory. 取而代之的是一个稀疏的索引You still need an in-memory index to tell you the offsets for some of the keys, but it can be sparse 支持range query disk writes are sequential the LSM-tree can support remarkably high write throughputConstructing and maintaining SSTables When a write comes in, add it to an in-memory balanced tree data structure (for example, a red-black tree). This in-memory tree is sometimes called a memtable. When the memtable gets bigger than some threshold, write it out to disk as an SSTable file In order to serve a read request, first try to find the key in the memtable, then in the most recent on-disk segment, then in the next-older segment, etc. From time to time, run a merging and compaction process in the background to combine segment files and to discard overwritten or deleted values This scheme works very well. It only suffers from one problem: if the database crashes, the most recent writes (which are in the memtable but not yet written out to disk) are lost. In order to avoid that problem, we can keep a separate log on disk to which every write is immediately appended, just like in the previous section. That log is not in sorted order, but that doesn’t matter, because its only purpose is to restore the memtable after a crash. Every time the memtable is written out to an SSTable, the corresponding log can be discarded. Performance optimizations 当查找一个不存在的key时，首先去memtable找，然后从近到远依次找segment，所以为了避免这种情况发生，storage engines often use additional Bloom filters B-TreesConstructing log-structured indexes 将数据拆分成一个个大小可变的segment，并且能够满足顺序写，与之相比的是B-Trees将数据拆分成大小固定的blocks or pages, traditionally 4 KB in size (sometimes bigger), 一次只能读或者写一个page 一个page就是树的一个节点，每个节点指向多个儿子，节点的儿子数量被称为branching factor 当加入一个key的时候，如果符合条件的page空间被占满，这时这个page会被拆分成2个page，然后再更新他们的parent指针Making B-trees reliable write-ahead log (WAL, also known as a redo log)This is an append-only file to which every B-tree modification must be written before it can be applied to the pages of the tree itself, When the data‐base comes back up after a crash, this log is used to restore the B-tree back to a consistent state concurrency control is required if multiple threads are going to access the B-tree at the same time, 此时需要用锁B-tree optimizations Instead of overwriting pages and maintaining a WAL for crash recovery, some databases (like LMDB) use a copy-on-write scheme. 改动过的page会存在另外一个地方，并且它的父亲page会指向这个新儿子 不用存整个key的名称，只存能标识它的‘缩写’，这样可以节约空间，增加一个page的branching factor，从而缩小depth 存在兄弟指针，保证顺序遍历key的时候不用回到父节点 当大范围查询的时候，直接顺序遍历叶子节点Comparing B-Trees and LSM-TreesAs a rule of thumb,LSM-trees are typically faster for writes,whereas B-trees are thought to be faster for reads one write to the database resulting in multiplewrites to the disk over the course of the database’s lifetime—is known as write amplification. LSM-trees 能维持更高的写吞吐量，一部分是因为更小的write amplification，另一部分是因为顺序写真实他妈快啊]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>B-tree</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Suffix Tree 后缀数组]]></title>
    <url>%2F2013%2F03%2F28%2Fsuffix-tree%2F</url>
    <content type="text"><![CDATA[前言这是13年3月28日的文章，那时的我在机房熬了一天一夜翻来覆去看罗穗骞的代码，最后才把这个后缀数组给整明白了，故有此文现在的我回想那过去的岁月，难免唏嘘不已，今时今日借整理此文，以缅怀那过去的岁月吧！原文链接 声明我的模板是根据 罗穗骞 和 网上一模板 相结合改编而来，层次更加分明，数组名称的选择是根据用途来定义的，总的来说应该更好理解一些先声明一些概念： k-后缀数组：我这里用的是 sa[ ] ( k ) k-名次数组：我这里用的是 rank[ ] ( k ) 思路知道rank[ ] (1) 先求出sa[ ] (1)，然后根据 sa[ ] (1) 和 rank[ ] (1) 调用sorting函数求出 sa[ ] (2)，再求出rank[ ] (2) 等等 总的过程是rank[ ] (1)—-&gt;sa[ ] (1) —&gt;rank[ ] (2) —&gt; sa[ ] (2) —&gt; rank[ ] (k) —-&gt;sa[ ] (k) Hint 我的数组小标全是从1开始的，程序运行前一定要初始化函数ini() 其它该有的东西都在代码里，建议一边看代码下面的图，一边理解！ 模板代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;#define N 3000//处理完成之后下标都是从1开始char s[N];//存原始数据int sum[N], rank[2*N], trank[2*N];//sum用来基数排序；trank === temp-rankint sa[N], tsa[N]; //这里tsa[]用来保存第二关键字排序后的结果int Top, n; //Top基数排序出现的极大值void ini() //初始化&#123; n=strlen(s); memset(sum,0,sizeof(sum)); memset(rank,0,sizeof(rank)); memset(sa,0,sizeof(sa)); Top=128;&#125;void sorting(int k)&#123; int p = 1; //利用sa排序第二关键字，求出tsa for(int i = n-k+1; i &lt;= n; i++) tsa[p++]=i; //超出范围的下标按下标顺序置其名次为最低 for(int i = 1; i &lt;= n; i++) if(sa[i]&gt;=k+1) tsa[p++]=sa[i]-k; //按sa排名从小到大遍历，如果排名为i的某后缀(sa[i])位置在k后面，那么这个后缀肯定会在第二关键字排序 //(tsa[])中出现并且排在比较靠前的位置，这个后缀对应tsa[]中的位置为sa[i]-k memset(sum,0,sizeof(sum)); for(int i = 1; i &lt;= n; i++)sum[rank[i]]++; for(int i = 1; i &lt;= Top; i++)sum[i]+=sum[i-1]; for(int i = n; i &gt; 0; i--)sa[sum[rank[tsa[i]]]--]=tsa[i];//这句话应该是关键 //如果把tsa[i]换成i，那么就是对rank[i]按第一关键字排序求sa[]，事实上这段程序也是这样， //不过把i换成tsa[i]后会多一个功能，就是按第一关键字排序rank相同的情况下，会按第二关键字排， //这也正符合我们最终要求的sa[](2k)。具体方法是从tsa[n]到tsa[1]，让在第二关键字排名靠后的优先 //取sum较大的，取一次，sum--，如果后边第二关键字排名靠前的某后缀在第一关键字下rank和它相同， //那么它的sum就较小，在sa中排名就会靠前，服从排序规律！&#125;void get_sa()&#123; int p; for(int i = 0; i &lt; n; i++) rank[i+1]=s[i]; //仔细想一下，其实此时rank就是rank[](1); for(int i = 1; i &lt;= n; i++) sum[rank[i]]++; for(int i = 1; i &lt;= Top; i++) sum[i]+=sum[i-1]; //sum[i] means the number of the &lt;= rank[i]; for(int i = n; i &gt; 0; i--) sa[sum[rank[i]]--]=i; //sa[](1)构造完成 for(int k = 1; k &lt;= n; k&lt;&lt;=1) &#123; sorting(k); //由sa[](k)和rank[](k) 求 sa[](2k) //求rank[](2k) trank[sa[1]]=1; p=1; for(int i = 2; i &lt;= n; i++) &#123; if((rank[sa[i]]!=rank[sa[i-1]])||(rank[sa[i]+k]!=rank[sa[i-1]+k]))p++; trank[sa[i]]=p; &#125; for(int i = 1; i &lt;= n; i++)rank[i]=trank[i]; if(p&gt;=n)break; //rank[1,2……n]已经唯一了，即后缀大小已经唯一确定了，不需要继续执行了 Top=p;//下次基数排序的最大值 &#125;&#125;int height[N];void get_height()&#123; for(int i = 1, j = 0; i &lt;= n; i++) &#123; if(rank[i]==1)continue; for(;s[i+j-1]==s[sa[rank[i]-1]+j-1];)j++;//i从1开始，所以在原串中要-1 height[rank[i]]=j; if(j&gt;0)j--; &#125;&#125; int *RMQ=height;int mm[N];int best[20][N];void initRMQ(int n)&#123; int i,j,a,b; for(mm[0]=-1,i=1; i&lt;=n; i++) mm[i]=((i&amp;(i-1))==0)?mm[i-1]+1:mm[i-1]; for(i=1; i&lt;=n; i++)best[0][i]=i; for(i=1; i&lt;=mm[n]; i++)for(j=1; j&lt;=n+1-(1&lt;&lt;i); j++) &#123; a=best[i-1][j]; b=best[i-1][j+(1&lt;&lt;(i-1))]; if(RMQ[a]&lt;RMQ[b])best[i][j]=a; else best[i][j]=b; &#125;&#125;int askRMQ(int a,int b)&#123; int t; t=mm[b-a+1]; b-=(1&lt;&lt;t)-1; a=best[t][a]; b=best[t][b]; return RMQ[a]&lt;RMQ[b]?a:b;&#125;//求sufix(a)与sufix(b)的最长公共前缀长度，用上面的RMQ优化int lcp(int a,int b) //这里的a,b是字符串当中的位置，注意要从1开始&#123; int t; a=rank[a],b=rank[b]; if(a&gt;b) &#123; t=a; a=b; b=t; &#125; return height[askRMQ(a+1,b)];&#125; h[i] &gt;= h[i-1]-1的证明设suffix(k)是排在suffix(i-1)前一位的后缀，则它们的最长公共前缀显然是h[i-1]。那么，suffix(k+1)显然将排在suffix(i)的前面。并且，suffix(k+1)&amp;suffix(i) 相对于 suffix(k)&amp;suffix(i-1)来说就是同时去掉了第一位，即少了一位的匹配数。所以suffix(i)和前一名次后缀的最长公共前缀至少是h[i-1]-1 为什么是 至少h[i-1]-1的理解根据上面的证明我们可以得到suffix(k+1)&amp;suffix(i) == h[i-1]-1又因为suffix(k+1)显然将排在suffix(i)的前面所以 LCP(k+1,i) = h[i-1]-1 =min{ LCP(j-1, j) |k+1 ≤j ≤i } （LCP Theorem）&lt;= h[i]@(数据结构)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Suffix Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博弈进行时]]></title>
    <url>%2F2012%2F12%2F04%2Fgame-theory%2F</url>
    <content type="text"><![CDATA[前言这是 2012年12月04日 00:13:42 发表的博客，那时的我初生牛犊不怕虎，天天都在做final梦，在数据结构、动态规划还没整明白的情况下贸然开始搞博弈，实乃too simple。博弈现在基本上是忘到爪哇岛去了，投入的精力不知道还剩几斤几两。不过想想当年，确实挺热血的嘛！ 小知识点HDOJ2176 取(m堆)石子游戏 [输出第一步走法] 若给出的是必胜状态：a1^a2^…….^an=k,(其中k不为零)，那么我们的目的是要把必胜状态转化为必败状态从 而使得先手胜利。 若a1^a2^…^an!=0，一定存在某个合法的移动，将ai改变成ai’后满足a1^a2^…^ai’^…^an=0。 若a1^a2^…^an=k，则一定存在某个ai，它的二进制 表示在k的最高位上是1（否则k的最高位那个1是怎么得到的）。这时ai^k&lt;ai一定成立。 则我们可以将ai改变成ai’=ai^k，此时a1^a2^…^ai’^…^an=a1^a2^…^an^k=0 HDOJ1907&amp;&amp;POJ3480&amp;ZOJ3113 John [ANTI-SG]必胜策略： sg值为0 且 全为孤单堆； sg值不为0 且 不全为孤单堆； NP暴力打表||找规律HDOJ1525&amp;POJ2348 Euclid’s Game [找规律博弈]注意第一次出现a/b&gt;1的位置为必胜 HDOJ1564 Play a game [找规律]（重点是打表的方法，N P定理）打表发现奇偶性规律 HDOJ1404 Digital Deletions [SG博弈]（暴力打表，NP定理）老实说，这个表不太好打。从P-&gt;N一种是在让某一位增加；另一种是在后面补0 裸求sg值HDOJ3032 Nim or not Nim? [找规律]SG打表重点是sg函数的求法，把一堆变成两堆，有嵌套的感觉。 HDOJ1729 Stone Game [SG博弈]这题我开始打了个表，，什么规律都没找出来，还是得靠分析，，可我不会啊。。。。 我的理解：可以先模拟一下，初始为（27,2），子递归状态为（4,2）然后返回2，结束。然后我从前往后推，A先拿2个，变为（27,4）状态，然后无论B怎么拿都无法拿完，所以B很保守的只拿一个，变为（27,5）状态，然后A轻松拿完；所以A获胜了。所以我的理解是子递归状态返回值的意义在于 先手能否成功到达必败点，让后手必败。 那么对于这题对于每一堆，放石子放满就想当于满的时候取s-c个，反向只是让我理解题意更深。 首先我们知道（S，S）这个局面是必败局面。 对于每一堆能加的数量有限，而当c的值（大于或者等于）D=sqrt(s) 或者 D=sqri（s）+1的时候就可以一次完成，就是说可以从当前局面到达（S，S）的局面，所以当前局面是必胜局面。 而这种情况下，你能造成的局面有集合A={0,1,2,…,s-c-1}；因为你可以去s-c，s-c-1，s-c-2，…..，1；那么对应mex(x)函数（即A中未出现的最小的一个数字），那么自然该局面的SG值就是s-c了； 另外当c的值小于D的时候，是不可能一下子加满的，因为c*c+c绝对是小于s的；那么小于D的局面一定能够是必输的吗？很显然不是的。 对于（S，D-1）这个局面，一定是必输，因为他能到的局面都是必胜！现在c小于D，那么如果（S，C）这个局面能到（S，D）；就代表这个局面是必胜的。所以现在SG值要在新集合（D，C）中求，而求法与上面的相同求新的D，所以可以用递归函数：当C&gt;D时，返回（S-C） 差不多就是这样。 其实D = sqrt(s);这里算是个加速，要不然就要：while(d*d+d &lt; S) d++;这样会很慢的。 思路：这题明显的sg函数。可惜我纠结了半天没想起思路来。设当前的箱子容量为si，求出一个t满足：t + t * t &lt; si，若是当前箱子里有ci颗石头， ci &gt; t 则必胜； ci == t 则必败； ci &lt; t不可立即断定，将t作为si递归调用函数。 当满足ci &gt; t时，return si - ci 作为当前状况的sg值。因为： 当ci在si点时，为有向图的端点，出度为0，也就是必败点，所以sg值为0； 当ci 位于si - 1时，ci的端点可能的sg值构成的凑集为{0}，所以当前sg值 为1； 当ci 位于si - 2 时，ci的端点可能的sg值构成的凑集为{0， 1}，所以当前的sg值为2； 可得，ci地点地位的sg值为si - ci； [TopCoder]SRM 561 DIV1 500：CirclesGame题意：给你n&lt;=50个不相交的圆（可能包含）。Alice 和Bob博弈，Alice先手，每次每人都可以选择一个没有红点的圆，在圆内放置一个红点，最后没法放红点的一方失败。 算法分析：圆与圆没有相交，故可以把每个圆看成一个结点，直接包含看成点与点之间的边，于是得到一个森林。原题变成在这个森林里博弈，每次选取一个结点，可以干掉他和他的所有祖先结点，干掉最后一个点的获胜。首先我们来考虑每颗树的sg函数。我们可以选择这棵树上任意一个结点操作，去掉这个结点以及其祖先结点后剩下的树的sg函数取异或便是当前操作所得状态的sg值，去掉这些sg值，剩下sg值的最小值即为这棵树的sg函数（看不懂的先好好学学博弈论）。求出每颗树的sg函数，最后取异或便是最终的sg函数，结果不等于0先手胜否则后手胜。 （这题不太好写，子状态神马递归容易出错） starcaseHDOJ3389 Game [Staircase Nim]变形要注意这类博弈的特点：一定是奇堆移动到偶堆，偶堆移动到奇堆。 题意：有N堆石子，每堆石子都有一定的石子数，Alice和Bob轮流玩一个游戏，游戏的规则是，每回合一个人可以选择1-n堆石子中的某一堆进行操作，操作是：假设选择操作的那堆石子的编号为A，现在还要选择一堆石子B，满足B&lt;A &amp;&amp; (A+B)%2==1 &amp;&amp; (A+B)%3==0，然后可以将A中至少一颗石子移到B中去，第一个不能进行合法操作的人输，问谁能赢。 思路：这是一个阶梯博弈的题目，首先我们可以发现，只有1 ，3 ，4 三个数是没有前缀的， 也就是terminal状态，其余的每个状态我们都可以计算出每个编号到这几个terminal的步数（当然有的编号的步数并不唯一，但是奇偶性是唯一的）。接下去我们就会发现，每次从一个奇数步的点，一定是要移到到 一个偶数步的点上去，也就是说每次只能移到奇数步，这个通过编号自身的奇偶性就可以证明了。这样就转化为了阶梯博弈的类型了，我们只需要关注奇数步编号出的石子的数量就可以了，如果奇数步编号处的石子的Nim和为0，则必败，不为0则必胜。接下去我们就简单地证明一下这个策略：如果移动的是奇数步位置的石子，则一定是移动到偶数步的位置，这时候我们只需要按照Nim博弈的必胜策略进行游戏就可以赢；如果移动的是偶数步数编号位置的石子，则移动是移动到奇数步的位置，这时候我们只需要将刚刚移动过来的石子移动到下一个偶数步位置，原来的Nim局面并没有变化，变化的只是偶数步石子的数量。这样我们就证明了原游戏可以转化为Nim游戏。 POJ1704 Georgia and Bob [阶梯博弈] (下面一题是这个的加强版，直接把这种最纯粹的看做模型)我们把棋子按位置升序排列后，从后往前把他们两两绑定成一对。如果总个数是奇数，就把最前面一个和边界（位置为0）绑定。在同一对棋子中，如果对手移动前一个，你总能对后一个移动相同的步数，所以一对棋子的前一个和前一对棋子的后一个之间有多少个空位置对最终的结果是没有影响的。于是我们只需要考虑同一对的两个棋子之间有多少空位。这样一来就成了N堆取石子游戏了. HDOJ4315 Climbing the Hill [阶梯博弈] （有待提高）这题压力山大，看了好久： 此题的简化版本是不考虑King的存在，双方一直走到不能走的一方为负。此时的解法是根据人数的奇偶性：把人从上顶向下的位置记为a1,a2,…an, 如果为偶数个人，则把a(2i-1)和a(2i)之间的距离当做一个Nim堆，变成一共n/2堆的Nim游戏；如果为奇数个人，则把山顶到a1的距离当做一个Nim堆，a(i2)到a(i2+1)的距离当做Nim堆，一共(n+1)/2堆。 考虑King的情况和上述版本几乎一致，只要把King当作普通人一样处理即可。除了两种特殊情况：1. 当King是第一个人时，Alice直接胜 2. 当King是第二个人且一共有奇数个人时，第一堆的大小需要减1。 题意如上图所示：有 n 个球分别在 n 个不同的位置，Alice 和 Bob 依次选择一个球向上移动，上面有球不能越过，谁最后把红球移出谁就赢！ 分析1、n 为偶数时：问题简化一下，假设全都是黄球，谁把最后一个球移出谁就赢（a1,a2） (a3,a4) …… ( a(2n-1) , a(2n) ) ……（a(n-1),an）其中第 i 个球与第 i+1 个球是相邻的，i 为基数，谁面对这个状态谁就必输。理由很简单，先手移动第 i 个球，后手移动第 i+1 个球，使之仍然保持必赢状态。回到原问题谁先移出红球谁就赢，假设红球不是第一个球（因为第一个球Alice直接就赢了）很显然如果红球在偶数位置后手必赢，如果在基数 i 位置，则只需将 第 i-1 个球移到第一个位置就ok了。所以与红球位置无关。至于产生这个状态（a1,a2） (a3,a4) …… ( a(2n-1) , a(2n) ) ……（a(n-1),an），那么就是简单的 Nim问题了2、n 为基数时：假设红球是第1、2个球。（a1） (a2,a3)（a4,a5）…… (a(2n),a(2n+1)) …… (a(n-1),an) 谁面对这个状态必赢！理由是先手直接把 a1 取走然后就变成上面的情况了，如果红球在第 2 个位置那么就是必输状态。 与staircase的联系：对于这个题目，从后向前两两划分成一组，组内相当于奇数阶梯上的石子，组间相当于偶数阶梯上的石子，移动组内的前面石子一定能够通过移动当前组的后面石子相同步数达到平衡态，移动组内后面的石子一定能够通过移动其他组后面石子达到平衡态，具体因为King的原因需要处理细节，上面已经说清楚了，不再赘述。 翻硬币游戏HDOJ3537 Daizhenyang’s Coin[翻硬币游戏]SG打表 （待解决）这题表我是打出来了，规律没找出来（注意还要对编号排序判重） HDOJ3951 Coin Game [找规律]题意给你n个硬币排成一圈，编号1-n,只能翻转连续的1~k个的硬币。翻最后一枚硬币者赢。 思路博弈 若k=1,则一次只能去翻一枚，奇数先手赢，偶数后手赢。 若k&gt;1: 先手一次翻完，先手赢； 先手不能翻完，第一次必定断环。只要后手一次翻完，或将其分为相等数量的两段， 之后先手怎么操作后手就怎么操作，后手必赢。 树&amp;&amp;删边HDOJ3094 A tree game[有向无环树形图SG博弈]最基础的删边 HDOJ3197 Game[树形SG博弈]砍树树的删边游戏，把多棵树的根异或起来就行了 HDOJ3590 PP and QQ[树的删边游戏+ANTI-SG]先手必胜当且仅当 游戏的SG函数不为0且游戏中某个单一游戏的SG函数大于1 游戏的SG函数为0且游戏中没有单一游戏的SG函数大于1 POJ3710 Christmas Game[无向图删边]Tarjan算法找出环，处理环之后，便是经典的删边游戏。拥有奇数条边的环可简化为一条边，偶数条边的环可简化为一个节点。]]></content>
      <categories>
        <category>Game theory</category>
      </categories>
      <tags>
        <tag>Nim</tag>
        <tag>SG</tag>
      </tags>
  </entry>
</search>
